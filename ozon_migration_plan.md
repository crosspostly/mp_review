# План миграции и интеграции OZON функций

## 1. Анализ существующего файла ozon_functions.gs
- В файле содержатся:
  - Критические фиксы адаптивной и обычной пагинации для Ozon API
  - Функции progress (memory system): getStartingPageForStore, updateStorePageProgress
  - Логика фильтрации, нормализации и сортировки
- Почти вся эта логика уже **интегрирована** или скопирована в code.gs с доработками (например, есть свои getStartingPageForStore и updateStorePageProgress с привязкой к store.id, а не store.name)
- Вызываемые из code.gs функции: getOzonFeedbacksWithAdaptivePagination, getOzonFeedbacksWithStandardPagination, processFeedbacksPageForOzon, applySortingPreferences — используются через обёртку getOzonFeedbacks (code.gs)

## 2. На что обращать внимание:
- В code.gs основной точкой входа по-прежнему остаётся getOzonFeedbacks(...), которая вызывает *только две* ф-ции из ozon_functions.gs
- Версии progress-функций в code.gs и ozon_functions.gs НЕ совпадают по формату ключей и логике (store.id vs store.name)
- Фильтрация результатов и сортировки реализованы схожим образом

## 3. Решение по миграции и дальнейшему использованию
- Оставляем ozon_functions.gs для совместимости, но **весь прогресс/логику переводим на версию с store.id** (как в code.gs)
- Централизуем апдейт и чтение прогресса через code.gs (где уже id)
- Все новые улучшения (и хранение прогресса, и фильтры) реализовать только через store.id и текущую версию code.gs
- Оставить ozon_functions.gs как бэкап, удалять не спешить ; можно использовать его процессинговую логику для unit-тестов или аварийного восстановления

## 4. Следующие шаги:
1. Всю новую бизнес-логику строить вокруг code.gs и новых функций progress (опираясь на store.id)
2. При необходимости использовать отдельные функции нормализации (например, processFeedbacksPageForOzon) можно инлайнить нужные куски в code.gs
3. Следить за уникальностью ключей прогресса, чтобы не возникало рассинхронизации

## 5. TODO
- [ ] Провести финальную ревизию всех точек вызова ozon_functions.gs -> code.gs
- [ ] Согласовать формат прогресса (единый: store.id)
- [ ] Фиксировать ключевые архитектурные решения по мере миграции здесь

# План внедрения новой архитектуры Ozon и автозапуска триггеров

## 1. Общий подход
- Для каждого магазина при его включении автоматически создаётся индивидуальный триггер на функцию processStore_<ID>().
- Для отключения или удаления магазина триггер удаляется.
- Вся логика прогресса, фильтрации и обработки отзывов теперь ведётся по store.id.
- Главная обработка для Ozon — инкрементальное получение отзывов с перекрытием дат, фильтрацией дубликатов, нормализацией и записью в лист магазина.

## 2. Детали реализации
1. **Функции триггеров:**
   - ensureStoreTrigger(store, intervalMinutes=240) — постановка триггера (4 часа по умолчанию)
   - deleteStoreTrigger(storeId) — удаление
   - syncAllStoreTriggers() — восстановление и синхронизация триггеров на старте/по требованию
2. **Интеграция с saveStore/deleteStore:**
   - saveStore при включении (isActive) вызывает ensureStoreTrigger
   - saveStore при выключении и deleteStore вызывают deleteStoreTrigger
3. **Ozon обработка:**
   - processOzonStoreIncremental(store) — точка входа инкрементальной обработки
   - collectOzonReviewsIncremental(store) — только новые за нужный период, надёжная фильтрация
   - updateOzonStoreProgress(storeId, progress) — обновление прогресса с помощью store.id

## 3. Этапы внедрения
1. **Добавить и протестировать функции управления индивидуальными триггерами** в code.gs
2. **Модифицировать saveStore/deleteStore** для автозапуска/снятия триггера
3. **Создать необходимое количество processStore_<ID> функций или универсальную-роутер**
4. **Всю Ozon обработку модернизировать под работу с прогрессом и фильтрацией на базе store.id**
5. **Обновить README/документацию с архитектурой триггеров и прогресса**

## 4. Важно!
- Для Google Apps Script лимит триггеров — 20. Если магазинов будет больше, реализовать batched-триггер или сгруппировать магазины по расписанию.
- Все уникальные ключи прогресса и конфигураций должны использовать только store.id для однозначности.

## 5. Проверка и релиз
- [ ] Протестирована автоматическая постановка/удаление/синхронизация триггеров
- [ ] Оценена производительность one-store-per-trigger
- [ ] Проверена корректность сбора, записи и отбора отзывов Ozon
- [ ] Пользовательская документация дополнена

## 6. Инкрементальная обработка Ozon: реализация
- collectOzonReviewsIncremental(store) теперь обеспечивает сбор только новых отзывов с перекрытием 24 часа (или больше по параметру).
- filterDuplicateOzonReviews гарантирует отсутствие дублей благодаря сверке с ID в листе магазина.
- Прогресс хранится в ScriptProperties как ozon_inc_progress_<storeId> (ключ — только id!). lastDate обновляется автоматически по batch результату.
- Инкрементальный обход заменяет классический getOzonFeedbacks при обработке через индивидуальные триггеры или ручной запуск processStore_<id>.
- Весь процесс полностью логируется: диапазон дат, собранные/новые, сколько реально попало в лист.
- Для расширенного юзкейса можно легко управлять глубиной перекрытия, параметром overlapHours в collectOzonReviewsIncremental.
- Логика масштабируется на любое количество магазинов: нет зависимости от глобального состояния и устаревших ключей.
